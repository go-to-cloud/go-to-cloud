import{_ as s,c as o,o as e,N as a}from"./chunks/framework.cd9250a1.js";const c="/assets/project_modules.f2ca93f6.png",l="/assets/project_code_import.a94ee2d6.png",p="/assets/project_code_list.d0f80af9.png",t="/assets/project_build_new.df26643f.png",n="/assets/project_build_step1.28d4c29b.png",d="/assets/project_build_step2.304b1a4a.png",i="/assets/project_build_step4.4d3f594f.png",r="/assets/project_deploy_new.2933e9dc.png",u="/assets/project_deploy_list.b871ad8e.png",f=JSON.parse('{"title":"管理模块","description":"","frontmatter":{},"headers":[],"relativePath":"guide/project/manage.md","lastUpdated":1684328223000}'),m={name:"guide/project/manage.md"},b=a('<h1 id="管理模块" tabindex="-1">管理模块 <a class="header-anchor" href="#管理模块" aria-label="Permalink to &quot;管理模块&quot;">​</a></h1><blockquote><p>阅读时间大约需要10分钟</p></blockquote><p>项目列表中有一项<code>管理模块</code>，如下图所示</p><p><img src="'+c+'" alt="管理模块"></p><blockquote><p>从左到右依次是: <code>代码仓库</code>, <code>持续集成</code>, <code>持续部署</code>, <code>制品仓库</code></p></blockquote><h2 id="代码仓库" tabindex="-1">代码仓库 <a class="header-anchor" href="#代码仓库" aria-label="Permalink to &quot;代码仓库&quot;">​</a></h2><p>代码仓库是项目中代码的来源，一个项目通常是由一个或多个代码仓库来实现</p><p>点击代码仓库图标，可以看到已导入项目中的仓库，如果需要导入新的代码仓库，可以点击右上角<code>导入代码仓库</code>按钮进行</p><div class="info custom-block"><p class="custom-block-title">注意</p><p>可以被导入的代码仓库都是在<code>配置环境 - 代码仓库</code>中绑定过的代码仓库</p></div><h3 id="导入代码仓库" tabindex="-1">导入代码仓库 <a class="header-anchor" href="#导入代码仓库" aria-label="Permalink to &quot;导入代码仓库&quot;">​</a></h3><p><img src="'+l+'" alt="导入代码仓库"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如上图所示，可以导入项目有关的所有代码仓库后再点击<code>关闭</code>按钮</p></div><h3 id="代码仓库列表" tabindex="-1">代码仓库列表 <a class="header-anchor" href="#代码仓库列表" aria-label="Permalink to &quot;代码仓库列表&quot;">​</a></h3><p><img src="'+p+'" alt="代码仓库列表"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>点击代码仓库地址可以跳转到git仓库</p></div><p><code>移除代码仓库</code> 仅仅是将代码仓库从项目中移除，代码不会受到任何影响，如果需要，可以重新导入代码仓库</p><h2 id="持续集成" tabindex="-1">持续集成 <a class="header-anchor" href="#持续集成" aria-label="Permalink to &quot;持续集成&quot;">​</a></h2><p>持续集成(<code>CI</code>)，在GTC中又称为<code>构建计划</code>（同类产品中也叫作流水线），作用是将指定代码分支编译打包为镜像后发布到<code>制品仓库</code></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>一个项目中往往会有多个构建计划，比如<code>开发阶段</code>、<code>测试阶段</code>、<code>预发阶段</code>等，这些不同的阶段往往对应不同的代码分支</p><p><code>生产阶段</code>一般不会单独创建构建计划，而是使用预发阶段的镜像作为生产环境的镜像</p></div><h3 id="创建构建计划" tabindex="-1">创建构建计划 <a class="header-anchor" href="#创建构建计划" aria-label="Permalink to &quot;创建构建计划&quot;">​</a></h3><p><img src="'+t+'" alt="创建构建计划"></p><p>每个构建计划均由以下四步组成</p><h4 id="step-1-选择构建环境-并填写计划名称" tabindex="-1">Step 1. 选择构建环境，并填写计划名称 <a class="header-anchor" href="#step-1-选择构建环境-并填写计划名称" aria-label="Permalink to &quot;Step 1. 选择构建环境，并填写计划名称&quot;">​</a></h4><p><img src="'+n+`" alt="step1"></p><div class="tip custom-block"><p class="custom-block-title">构建环境</p><p>构建环境是运行打包镜像的基础环境，编译代码所依赖的SDK依然是由Dockerfile的基础镜像指定</p><blockquote><p>注意：最终的镜像产物依然是由项目中的Dockerfile控制</p></blockquote><p><code>GTC</code>内置了<code>.Net</code>、<code>Golang</code>、<code>Java</code>、<code>NodeJS</code>作为基础构建环境</p></div><blockquote><p>如果内置的环境无法满足需求，可以在<code>输入栏</code>中输入基础镜像拉取地址</p></blockquote><blockquote><p>注意这个地址需要一个完整可被拉取镜像的地址</p></blockquote><h5 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h5><p>1️⃣ nginx镜像</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">pull</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">nginx:stable</span></span>
<span class="line"></span></code></pre></div><p>那么在<strong>输入栏</strong>中就要输入 <code>nginx:stable</code></p><p>2️⃣ dotnet sdk 8.0预览版镜像</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">pull</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">mcr.microsoft.com/dotnet/sdk:</span><span style="color:#F78C6C;">8.0</span><span style="color:#C3E88D;">-preview</span></span>
<span class="line"></span></code></pre></div><p>那么在<strong>输入栏</strong>中就要输入 <code>mcr.microsoft.com/dotnet/sdk:8.0-preview</code></p><h4 id="step2-选择代码仓库及分支" tabindex="-1">Step2. 选择代码仓库及分支 <a class="header-anchor" href="#step2-选择代码仓库及分支" aria-label="Permalink to &quot;Step2. 选择代码仓库及分支&quot;">​</a></h4><p><img src="`+d+'" alt="代码仓库"></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Git地址中可以看到导入到项目中的仓库地址，选择仓库后，<code>构建分支</code>将会列出这个代码仓库下的所有分支</p></div><h4 id="step3-镜像制品设置" tabindex="-1">Step3. 镜像制品设置 <a class="header-anchor" href="#step3-镜像制品设置" aria-label="Permalink to &quot;Step3. 镜像制品设置&quot;">​</a></h4><p><img src="'+i+`" alt="镜像制品"></p><blockquote><p>以下图代码结构为例</p></blockquote><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">.</span></span>
<span class="line"><span style="color:#A6ACCD;">├── LICENSE</span></span>
<span class="line"><span style="color:#A6ACCD;">├── README.md</span></span>
<span class="line"><span style="color:#A6ACCD;">├── src</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── Solution.sln</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── Dockerfile</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── 工程1</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── 工程1.csproj</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── ...</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── 工程2</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── 工程2.csproj</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── ...</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── 工程3</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── 工程3.csproj</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── ...</span></span>
<span class="line"><span style="color:#A6ACCD;">├── test</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── XUnitTest</span></span>
<span class="line"><span style="color:#A6ACCD;">│       ├── XUnitTest.csproj</span></span>
<span class="line"><span style="color:#A6ACCD;">│       ├── BaseTest.cs</span></span>
<span class="line"><span style="color:#A6ACCD;">│       ├── ....cs</span></span>
<span class="line"><span style="color:#A6ACCD;">└── ...</span></span>
<span class="line"></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">项目所在目录</p><p>填写代码仓库中项目相对于仓库的路径</p><p>以上图为例，项目位于<code>src</code>目录，因此 <code>项目所在目录</code> 设置为<code>/src</code></p></div><div class="warning custom-block"><p class="custom-block-title">Dockerfile</p><p>填写代码仓库中的Dockerfile文件路径，<strong>含Dockerfile文件名</strong></p><p>注意，Dockerfile是相对于 <code>项目所在目录</code>，如上图中，将<code>项目所在目录</code>设置为/src，由于<code>Dockerfile</code>位于src目录中，则此处仅需填写<code>Dockerfile</code>即可</p></div><div class="info custom-block"><p class="custom-block-title">制品名称</p><p>在制品仓库中显示的镜像名称，不要带tag，比如go-to-cloud-1.2.3，<s>不能使用go-to-cloud-1.2.3:latest</s></p><p>几种推荐做法：</p><p>分支名作为制品名称的一部分，比如go-to-cloud-feature-xxx</p><p>项目名作为制品名称的一部分，比如go-to-cloud-1.2.3</p></div><div class="info custom-block"><p class="custom-block-title">制品仓库</p><p>存放构建产物（镜像）的仓库，在<code>配置环境 - 制品仓库</code>中配置的仓库会在下拉列表中出现，按实际情况选择即可</p></div><h2 id="持续部署" tabindex="-1">持续部署 <a class="header-anchor" href="#持续部署" aria-label="Permalink to &quot;持续部署&quot;">​</a></h2><p>持续部署(<code>CD</code>)，在GTC中称为<code>部署方案</code>，一个部署方案负责将一个构建计划的产物（镜像）发布至对应的环境中</p><h3 id="创建部署方案" tabindex="-1">创建部署方案 <a class="header-anchor" href="#创建部署方案" aria-label="Permalink to &quot;创建部署方案&quot;">​</a></h3><p><img src="`+r+`" alt="创建部署方案"></p><details class="details custom-block"><summary>部署环境</summary><p>镜像运行的服务器，在<code>配置环境 - 部署环境</code>中配置的环境会在下拉列表中出现，按实际情况选择即可</p></details><details class="details custom-block"><summary>名字空间</summary><p>即k8s中的名字空间，一般服务于同一业务的应用会放在同一个名字空间</p><p>比如go-to-cloud是由前端(front)和后端(backend)两个应用组成</p><p>那我们可以将这两个应用的镜像部署到同一个名字空间(gotocloud)中</p></details><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果下拉列表中没有符合实际的名字空间，请先确定部署环境是否正确，或者直接在名字空间栏中输入，GTC会自动创建这个名字空间</p></div><details class="details custom-block"><summary>镜像名称</summary><p>用于运行的镜像，会从和项目有关的制品仓库中加载</p><p>由于镜像可能会比较多，因此可以在输入栏中<strong>输入关键字进行过滤</strong></p></details><details class="details custom-block"><summary>部署版本</summary><p>选择镜像后，部署版本中将会加载镜像的历史版本</p><p>通常来说，我们会选择<code>latest</code>作为部署版本，这样每次构建不用重新选择版本，系统会自动部署最新一次构建的镜像</p></details><div class="info custom-block"><p class="custom-block-title">其他参数</p><ol><li>副本数量：即Pod数量，根据实际情况选择，也可以在完成部署后再调整</li><li>端口映射：<code>服务端口</code>表示应用本身定义的端口，<code>容器端口</code>是指容器对外暴露可被外部访问的端口，通常来说我们会将这两个端口定义为同一个，即<code>容器端口</code>跟随<code>服务端口</code>，<code>节点端口</code>即<code>NodePort</code>，默认是30000-32767，如果配置了<code>节点端口</code>，那么外部可以直接访问此端口</li><li>环境变量：为应用设置的环境变量，比如以下代码中就会使用到环境变量<code>ENV</code>，这就需要在这一栏参数中配置具体的键值对</li></ol><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-WrL6A" id="tab-KZZO3GZ" checked="checked"><label for="tab-KZZO3GZ">csharp</label><input type="radio" name="group-WrL6A" id="tab-brp62Va"><label for="tab-brp62Va">go</label></div><div class="blocks"><div class="language-csharp active"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Environment</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">GetEnvironmentVariable</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ENV</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">os</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Env</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ENV</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div></div></div></div><ol start="5"><li>资源配置：限制容器可使用的内存和CPU资源，关于资源配置请参阅<a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes" target="_blank" rel="noreferrer">k8s的相关介绍</a></li><li>健康检查：k8s检测容器是否可用的接口，默认是<code>http</code>类型接口，地址：<code>healthz</code>，应当为每个应用都实现这个健康地址，因此这是一个必选项</li></ol><p>配置完成后点击<code>提交</code>或<code>提交并部署</code>即完成方案的创建，选择后者可以立即执行一次部署</p><h3 id="部署列表" tabindex="-1">部署列表 <a class="header-anchor" href="#部署列表" aria-label="Permalink to &quot;部署列表&quot;">​</a></h3><p><img src="`+u+'" alt="部署列表"></p><blockquote><p>创建方案后，可以在列表中看到基本参数，包括部署的<code>名字空间</code>，暴露的<code>端口映射</code>，镜像名称和版本以及环境变量</p></blockquote><p>列表右侧的<code>操作</code>选项可以执行<code>立即部署</code>（或者<code>重新部署</code>）,查看<code>部署历史</code>，<code>删除部署方案</code>等操作</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果已经部署过，会在<code>操作</code>选项中看到一项<code>转到应用监控</code></p><p>在应用监控中我们可以伸缩容器的副本、重启服务，查看容器运行日志，甚至进入容器内部执行脚本命令</p></div><h2 id="制品仓库" tabindex="-1">制品仓库 <a class="header-anchor" href="#制品仓库" aria-label="Permalink to &quot;制品仓库&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>与<code>配置环境 - 制品仓库</code>类似，区别是只能看到和这个项目相关的镜像制品，并且无法删除制品记录</p></div>',64),h=[b];function k(C,g,y,D,A,_){return e(),o("div",null,h)}const q=s(m,[["render",k]]);export{f as __pageData,q as default};
